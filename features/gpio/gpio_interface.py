"""
GPIO Factory Module
Provides the appropriate GPIO implementation based on platform
"""
import logging
from typing import Protocol, Union, List, Tuple, Optional, Callable, Literal, runtime_checkable, Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Type definitions from RPi.GPIO
Channel = Union[int, List[int], tuple[int, ...]]
Value = Union[Literal[0, 1], bool, List[Union[Literal[0, 1], bool]], Tuple[Union[Literal[0, 1], bool], ...]]
EventCallback = Callable[[int], object]

@runtime_checkable
class GPIOProtocol(Protocol):
    def setup(self, channel: Channel, direction: Literal[0, 1], pull_up_down: int = 20, initial: int = -1) -> None: ...
    def cleanup(self, channel: Optional[Channel] = -666) -> None: ...
    def output(self, channel: Channel, value: Value) -> None: ...
    def input(self, channel: int, /) -> bool: ...
    def setmode(self, mode: Literal[10, 11], /) -> None: ...
    def getmode(self) -> Optional[Literal[10, 11]]: ...
    def add_event_detect(self, channel: int, edge: int, callback: Optional[EventCallback] = None, bouncetime: int = -666) -> None: ...
    def remove_event_detect(self, channel: int, /) -> None: ...
    def event_detected(self, channel: int, /) -> bool: ...
    def add_event_callback(self, channel: int, callback: EventCallback) -> None: ...
    def wait_for_edge(self, channel: int, edge: int, bouncetime: int = -666, timeout: int = -1) -> Optional[int]: ...
    def gpio_function(self, channel: int, /) -> int: ...
    def setwarnings(self, gpio_warnings: bool, /) -> None: ...
    RPI_INFO: dict[str, Any] = {}

@runtime_checkable
class PWMProtocol(Protocol):
    def __init__(self, channel: int, frequency: float, /) -> None: ...
    def start(self, dutycycle: float, /) -> None: ...
    def ChangeDutyCycle(self, dutycycle: float, /) -> None: ...
    def ChangeFrequency(self, frequency: float, /) -> None: ...
    def stop(self) -> None: ...

